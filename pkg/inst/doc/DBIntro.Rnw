%\VignetteIndexEntry{RBerkeley: Getting Started with DB and R}
\documentclass{article}
\usepackage{hyperref}
\hypersetup{colorlinks,%
            citecolor=black,%
            linkcolor=blue,%
            urlcolor=blue,%
            }
\title{\bf RBerkeley: Getting Started with DB and R}
\author{Jeffrey A. Ryan}
\date{July 23, 2009}

\begin{document}

\maketitle
\tableofcontents

\section{Overview}
Berkeley DB is an embedded database application distributed
by Oracle for use in open source and commercial applications.

Widely deployed, Berkeley DB is used behind the scenes in
many of the most popular applications and services in
the world.  It is designed to be fast, memory-efficient, and
fully ACID compliant.  Berkeley DB, also known commonly as DB,
is shipped with APIs that allow for programatic access to
its features.  These directly supported language interfaces
include C, C++, Java and Tcl.  Contributed bindings exists
in a variety of programming languages, including Perl, Python, and
Ruby.

RBerkeley adds an {\tt R} language binding to this pool of options.

This document is not to extoll the virtues of DB, but rather to
provide a quick start to using the {\tt R} interface.  The general design
philosophy of RBerkeley will be explained, and some small examples
of using it in practice will be worked.

At present a large part of the very large API has been incorporated
into RBerkeley, including support for most database functions, cursors,
environments and mutexes.  Not yet supported, though in development,
are transactions, locks, and the rest of the API.

\section{Design Philosophy}
The RBerkeley interface is designed to be as close
to the native C API as possible.  Naming conventions are
maintained, with some simple substitutions to allow for legal
{\tt R} function names.  Most of the functionality exposed at
the R level is simply a thin wrapper to an internal call
to the C wrapper around the C API calls.

Some additional functionality and function calls are
included to offer a more seamless user experience, as
well as provide a more direct connection to the syntax of
the C API, so as the official Oracle documentation can be used
once a basic syntax conversion is performed.

\section{Getting DB and RBerkeley}
Berkeley DB is most likely already available on your
system if you are running a unix or linux variant. The
location of the library files are system dependant, and
at present the configure script included with RBerkeley
tries to identify the correct locations.

\subsection*{Installing DB}
It is relatively simple to install the newest version
of DB directly from Oracle by following the instructions
included in the download from Oracle.  The remainder of this
section will assume the default location on POSIX systems. You
may need to alter your configuration files to build RBerkeley.

\subsection*{Installing RBerkeley}
Installing RBerkeley follows the standard R installation convention
of:

{\tt R CMD INSTALL RBerkeley\_0.0-1.tar.gz}


\noindent
[Additional details coming...]

\section{Database Basics}
The primary purpose of this document is not to
show how to use DB, that is
best understood by reading the official Oracle documentation.
Our intention is instead to show basic usage patterns,
from the R environment, using the RBerkeley package interface.

To begin, we will create a new database, add some R objects
to it and read them back.  This will give the most simplistic
use case.

\subsection{Opening a Database}
Here we create a new database handle, and open our test database.
<<loadRBerkeley, echo=FALSE>>=
library(RBerkeley)
system("rm myDB.db")
@

<<dbopen, keep.source=FALSE>>=
dbh <- db_create()
dbh
@
{\tt db\_create} can take some
additional parameters, but we use the defaults here.  The object returned
is of class {\tt DB}.

Next we open the database:
<<dbopen, keep.source=FALSE>>=
ret <- db_open(dbh, txnid=NULL, file="myDB.db", type="BTREE", flags=mkFlags(DB_CREATE, DB_EXCL))
db_strerror(ret)
@

The {\tt db\_open} call opens the underlying database. As with db\_create,
different parameters may be passed in. Some of these options will
be covered in later documentation, but for now the defaults are sufficient.
Users are directed to the official API for usage details.

\vspace{3mm}
\noindent
The return value from the {\tt db\_open} call is an integer value.
This is the behavior of the underlying API. The utility function
{\tt db\_strerror} can take this value and return a message to
R.  Additional error and message tools are available in the API, though
currently disabled.

\vspace{3mm}
\noindent
The {\tt \textcolor{blue}{dbh}} argument is the database handle (a {\bf DB} struct in the
official API).  This is from the previous {\tt db\_create} call.

\vspace{3mm}
\noindent
The {\tt \textcolor{blue}{txnid}} is the transaction handle (a {\bf DB\_TXN} struct in the
official API).  This may be specified as NULL if no transaction
capability is needed, and in the current version of RBerkeley transaction
support is disabled, so this needs to be passed as {\tt txnid=NULL}.

\vspace{3mm}
\noindent
The {\tt \textcolor{blue}{file}} argument is simply the name of the database we wish to open. 

\vspace{3mm}
\noindent
The {\tt \textcolor{blue}{type}} can
be one of any supported DB access methods.  These include BTREE, HASH, RECNO,
QUEUE or UNKNOWN, the latter for opening a database of unknown type.
The {\tt db\_open} function will accept a variety of variations
on these names, see that function for details.

\vspace{3mm}
\noindent
The {\tt \textcolor{blue}{flags}} argument in this example is used to
create the underlying database file if needed, i.e. if one is not present,
[{\bf DB\_CREATE}], but \emph{if and only if} one is not present [{\bf DB\_EXCL}]. Flags
are central to many of the advanced features in DB, and it is crucial to
understand what you can and can't specify.  Once again, the main
API documentation should be the considered the definitive guide.

One interesting non-API function found in RBerkeley is {\tt mkFlags}; this function provides
access to the internal constants defined by DB for use as flag
parameters to be passed to many of the internal functions. 

The C API allows for flags to be constructed via bitwise OR operations
on predefined DB constants.  In order to not map all constants into R, which
would be tedious, error-prone, and difficult to maintain, the
RBerkeley package passes a list of quoted or unquoted names from mkFlags
into C code which in turn performs this bitwise operation.  {\tt mkFlags} thus
allows for syntax very close in look and feel to the base C API, and at
the same time makes for a robust and safe mechanism to pass 
arbitrary combinations of flags correctly.  

<<mkFlags, keep.source=TRUE>>=
mkFlags(DB_CREATE)
mkFlags(DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL,DB_EXCL) # bitwise OR duplicates: no change
@

A programming note about this interface:
unquoted symbols are converted to character vectors and in turn concatenated into one
vector that is passed into the C level mkFlags function.  If illegal values are passed
they will simply be ignored in the calculation, and will produce a visible warning
regarding the specific invalid flag or flags that failed to be processed.
The return value will be unaffected by improper or duplicate settings.

\subsection{Adding Records}
A database needs to have content, if it is to be of use.
Berkeley DB stores records in databases as simple key-value pairs.  These
records can be organized with a variety of access schemes, all of which are
discussed at length in the official documentation.

The central difference between records in DB and records in a typical
relational database is that DB has no notion of type.  Records, both
key and data are simply byte-strings.  This provides tremendous flexibility
to the programmer, as it enables data to be stored in the most
natural format possible, or in a manner that is most in accordance with
expected usage patterns.

Byte-strings make it quite easy to store native R objects as \emph{key} or
\emph{data}, making additional processing unecessary.  Of course this also
leaves open the possibility of
creating a preprocessing model to match any arbitrary schema that is needed
by the final application.

The primary difference in the RBerkeley implementation of the DB API
is that most R objects are passed to R's {\tt serialize} before being
sent to the database. At the DB level, the API simply takes whatever
raw data is passed in without effort to process.
The only exception is for the R object type {\tt raw}
which is passed in {\emph as is}.  This convention allows for simplicity of use
from within R, yet offers the benefit of providing a direct interface
to the underlying flexibility of DB if the application/programmer
demands it.  All DB data must be be serialized, so this conversion from
R objects (always represented as type RAW internally by RBerkeley) to bytes 
is carried out in the package's C layer.

To add a record, the package and API support two primary functions:
{\tt db\_put} and {\tt dbcursor\_put}.  These correspond to the official
API functions {\tt DB->put} and {\tt DBcursor->put}, respectively.  We'll
take a look at each individually, as well as introduce the concept of the
DB cursor.

\subsubsection{db\_put \emph{aka} DB->put}
The most basic way to add data into a database is with {\tt db\_put}.
This takes a handful of arguments and adds a new record into the database,
and returns as is usual for most of the API, an integer value of the success
or failure.

An example or two is the best way to understand how to use.

<<dbput>>=
db_put(dbh, key="Ross", data="Ihaka")
db_put(dbh, key="Robert", data="Gentleman")
@

This takes the two R character vectors, and adds them as a key and data into
our database referenced by the {\tt dbh} handle we created earlier.

Internally it should be noted that it is the actual object being stored, after
being run through {\tt serialize}, and not the characters themselves.
If one wanted to simply store the raw character values, instead of R objects,
he could convert to a raw vector before passing into db\_put.

<<dbputraw>>=
db_put(dbh,key=charToRaw("Ross"),data=charToRaw("Ihaka"))
charToRaw("Ihaka")
@

\subsubsection{Cursors}
A second slightly more abstract way of adding keys is to use a cursor.
A cursor in database terminology is really nothing more than a pointer
to a record.  A cursor can traverse a database, and provides a host
of retrieval options that simply using {\tt db\_put} would be impossible for.

Using cursors or even explaining much beyond the above is outside the scope
of this document. The preceeding description should be sufficient to 
have a cursory understanding
what is happening internally. Yes, cursory.

To add a record with a cursor, we first need a valid cursor handle to our
database.  This is accomplished with a call to {\tt db\_cursor} using
a valid {\tt dbh} handle to an open database.

<<dbcursor>>=
dbc <- db_cursor(dbh)
@

As with most API calls, there are numerous argument that may be passed into
the creation call.  The cursor (mapping to the C API struct {\bf DBC})
is now ready for use.

To put a record in the database, we now use the appropriate {\emph cursor} method:

<<dbcursorput>>=
dbcursor_put(dbc, key=100L, data=5L, flags=mkFlags(DB_KEYLAST))
@

Again, the return value of 0 is an indicator of success.

Some important points regarding the flags allowed. 

\subsection{Retrieving Records}

\subsubsection{DB->get aka db\_get}
\subsubsection{Cursors}

\end{document}

