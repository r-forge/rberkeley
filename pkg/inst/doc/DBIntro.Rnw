%\VignetteIndexEntry{RBerkeley: Getting Started with DB and R}
\documentclass{article}
\usepackage{hyperref}
\hypersetup{colorlinks,%
            citecolor=black,%
            linkcolor=blue,%
            urlcolor=blue,%
            }
\title{\bf RBerkeley: Getting Started with DB and R}
\author{Jeffrey A. Ryan}
\date{July 23, 2009}

\begin{document}

\maketitle
\tableofcontents

\section{Overview}
Berkeley DB is an embedded database application distributed
by Oracle for use in open source and commercial applications.

Widely deployed, Berkeley DB is used behind the scenes in
many of the most popular applications and services in
the world.  It is designed to be fast, memory-efficient, and
fully ACID compliant.  Berkeley DB, also known commonly as DB,
is shipped with APIs that allow for programatic access to
its features.  These directly supported language interfaces
include C, C++, Java and Tcl.  Contributed bindings exists
in a variety of programming languages, including Perl, Python, and
Ruby.

RBerkeley adds an {\tt R} language binding to this pool of options.

This document is not to extoll the virtues of DB, but rather to
provide a quick start to using the {\tt R} interface.  The general design
philosophy of RBerkeley will be explained, and some small examples
of using it in practice will be worked.

At present a large part of the very large API has been incorporated
into RBerkeley, including support for most database functions, cursors,
environments and mutexes.  Not yet supported, though in development,
are transactions, locks, and the rest of the API.

\section{Design Philosophy}
The RBerkeley interface is designed to be as close
to the native C API as possible.  Naming conventions are
maintained, with some simple substitutions to allow for legal
{\tt R} function names.  Most of the functionality exposed at
the R level is simply a thin wrapper to an internal call
to the C wrapper around the C API calls.

Some additional functionality and function calls are
included to offer a more seamless user experience, as
well as provide a more direct connection to the syntax of
the C API, so as the official Oracle documentation can be used
once a basic syntax conversion is performed.

\section{Getting DB and RBerkeley}
Berkeley DB is most likely already available on your
system if you are running a unix or linux variant. The
location of the library files are system dependant, and
at present the configure script included with RBerkeley
tries to identify the correct locations.

\subsection*{Installing DB}
It is relatively simple to install the newest version
of DB directly from Oracle by following the instructions
included in the download from Oracle.  The remainder of this
section will assume the default location on POSIX systems. You
may need to alter your configuration files to build RBerkeley.

\subsection*{Installing RBerkeley}
Installing RBerkeley follows the standard R installation convention
of:

{\tt R CMD INSTALL RBerkeley\_0.0-1.tar.gz}


[Additional details coming...]

\section{Database Basics}
The primary purpose of this document is not to
show how to use DB, that is
best understood by reading the official Oracle documentation.
Our intention is instead to show basic usage patterns,
from the R environment, using the RBerkeley package interface.

To begin, we will create a new database, add some R objects
to it and read them back.  This will give the most simplistic
use case.

Here we create a new database handle, and open our test database.
<<loadRBerkeley, echo=FALSE>>=
library(RBerkeley)
@

<<dbopen, keep.source=TRUE>>=
dbh <- db_create()
dbh # a DB handle object
@
First we need to create a handle to open a database.  {\tt db\_create} can take some
additional parameters, but we use the defaults here.  The object returned
is of class {\tt DB}.

Next we open the database:
<<dbopen, keep.source=TRUE>>=
# open a database, call it myDB.db
ret <- db_open(dbh, txnid=NULL, file="myDB.db", type="BTREE", flags=mkFlags(DB_CREATE, DB_EXCL))
db_strerror(ret)
@

{\tt db\_open} opens the underlying database.  Once again,
different parameters may be passed in, and some of these will
be covered in later documentation, but for now this will suffice for
the introductory example. A definitive treatment should always
be referenced from the main DB documentation.

The {\tt txnid} is the transaction handle (a DB\_TXN handle in the
official API).  This may be specified as NULL if no transaction
capability is needed.  At present no transaction capabilities exist
in RBerkeley, so this needs to be set as NULL.

The file argument is simply the name of the database we wish to open. The type can
be one of any supported DB access methods.  These include BTREE, HASH, RECNO,
QUEUE or UNKNOWN, the latter for opening a database that you don't know the
type of.  The {\tt db\_open} function will accept a variety of variations
on these names, see that function for details.

Our flags argument says to create the database file if one is not present,
(DB\_CREATE), but if and only if one is not present. (DB\_EXCL). The flags
are central ot many of the advanced features in DB, it is imperative to
understand what you can and can't specify.  Once again, the main
program documentation should be the guide.

One interesting non-API function found in RBerkeley is {\tt mkFlags}; this provides
access to the internal constants defined by DB for use as flag
parameters to be passed to many of the internal functions. 

The C API allows for flags to be constructed via bitwise OR operations
on predefined DB constants.  In order to not map all constants into R, which
would be tedious, error-prone, and difficult to maintain, the
RBerkeley package passes a list of quoted or unquoted names from mkFlags
into C code which in turn performs this bitwise operation for us. mkFlags thus
allows for syntax very close in look and feel to the base C API, and at
the same time makes for a robust and safe mechanism to pass 
arbitrary combinations of flags correctly.  A note about this interface is that
unquoted symbols are converted to character vectors, and in turn to lists for
passing into the C level mkFlags function.  If illegal values are passed
they will simply be ignored in the calculation, and produce a visible warning
regarding the specific invalid flag or flags.

<<mkFlags, keep.source=TRUE>>=
mkFlags(DB_CREATE)
mkFlags(DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL,DB_EXCL) # bitwise OR no change
@

\end{document}

