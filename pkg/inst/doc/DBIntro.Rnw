%\VignetteIndexEntry{RBerkeley: Getting Started with DB and R}
\documentclass{article}
\usepackage{hyperref}
\hypersetup{colorlinks,%
            citecolor=black,%
            linkcolor=blue,%
            urlcolor=blue,%
            }
\title{\bf RBerkeley: Getting Started with DB and R}
\author{Jeffrey A. Ryan}
\date{July 23, 2009}

\begin{document}

\maketitle
\tableofcontents

\section{Overview}
Berkeley DB is an embedded database application distributed
by Oracle for use in open source and commercial applications.

Widely deployed, Berkeley DB is used behind the scenes in
many of the most popular applications and services in
the world.  It is designed to be fast, memory-efficient, and
fully ACID compliant.  Berkeley DB, also known commonly as DB,
is shipped with APIs that allow for programatic access to
its features.  These directly supported language interfaces
include C, C++, Java and Tcl.  Contributed bindings exists
in a variety of programming languages, including Perl, Python, and
Ruby.

RBerkeley adds an {\tt R} language binding to this pool of options.

This document is not to extoll the virtues of DB, but rather to
provide a quick start to using the {\tt R} interface.  The general design
philosophy of RBerkeley will be explained, and some small examples
of using it in practice will be worked.

At present a large part of the very large API has been incorporated
into RBerkeley, including support for most database functions, cursors,
environments and mutexes.  Not yet supported, though in development,
are transactions, locks, and the rest of the API.

\section{Design Philosophy}
The RBerkeley interface is designed to be as close
to the native C API as possible.  Naming conventions are
maintained, with some simple substitutions to allow for legal
{\tt R} function names.  Most of the functionality exposed at
the R level is simply a thin wrapper to an internal call
to the C wrapper around the C API calls.

Some additional functionality and function calls are
included to offer a more seamless user experience, as
well as provide a more direct connection to the syntax of
the C API, so as the official Oracle documentation can be used
once a basic syntax conversion is performed.

\section{Getting DB and RBerkeley}
Berkeley DB is most likely already available on your
system if you are running a unix or linux variant. The
location of the library files are system dependant, and
at present the configure script included with RBerkeley
tries to identify the correct locations.

\subsection*{Installing DB}
It is relatively simple to install the newest version
of DB directly from Oracle by following the instructions
included in the download from Oracle.  The remainder of this
section will assume the default location on POSIX systems. You
may need to alter your configuration files to build RBerkeley.

\subsection*{Installing RBerkeley}
Installing RBerkeley follows the standard R installation convention
of:

{\tt R CMD INSTALL RBerkeley\_0.0-1.tar.gz}


\noindent
[Additional details coming...]

\section{Database Basics}
The primary purpose of this document is not to
show how to use DB, that is
best understood by reading the official Oracle documentation.
Our intention is instead to show basic usage patterns,
from the R environment, using the RBerkeley package interface.

To begin, we will create a new database, add some R objects
to it and read them back.  This will give the most simplistic
use case.

Here we create a new database handle, and open our test database.
<<loadRBerkeley, echo=FALSE>>=
library(RBerkeley)
@

<<dbopen, keep.source=FALSE>>=
dbh <- db_create()
dbh
@
{\tt db\_create} can take some
additional parameters, but we use the defaults here.  The object returned
is of class {\tt DB}.

Next we open the database:
<<dbopen, keep.source=FALSE>>=
ret <- db_open(dbh, txnid=NULL, file="myDB.db", type="BTREE", flags=mkFlags(DB_CREATE, DB_EXCL))
db_strerror(ret)
@

The {\tt db\_open} call opens the underlying database. As with db\_create,
different parameters may be passed in. Some of these options will
be covered in later documentation, but for now the defaults are sufficient.
Users are directed to the official API for usage details.

\vspace{3mm}
\noindent
The return value from the {\tt db\_open} call is an integer value.
This is the behavior of the underlying API. The utility function
{\tt db\_strerror} can take this value and return a message to
R.  Additional error and message tools are available in the API, though
currently disabled.

\vspace{3mm}
\noindent
\subsection*{dbh}
The {\tt dbh} argument is the database handle (a {\bf DB} struct in the
official API).  This is from the previous {\tt db\_create} call.

\vspace{3mm}
\noindent
\subsection*{txnid}
The {\tt txnid} is the transaction handle (a {\bf DB\_TXN} struct in the
official API).  This may be specified as NULL if no transaction
capability is needed, and in the current version of RBerkeley transaction
support is disabled, so this needs to be passed as {\tt txnid=NULL}.

\vspace{3mm}
\noindent
\subsection*{file}
The {\tt file} argument is simply the name of the database we wish to open. 

\vspace{3mm}
\noindent
\subsection*{type}
The {\tt type} can
be one of any supported DB access methods.  These include BTREE, HASH, RECNO,
QUEUE or UNKNOWN, the latter for opening a database of unknown type.
The {\tt db\_open} function will accept a variety of variations
on these names, see that function for details.

\vspace{3mm}
\noindent
\subsection*{flags}
The {\tt flags} argument in this example is used to create the underlying database file if one is not present,
({\bf DB\_CREATE}), but if and only if one is not present. ({\bf DB\_EXCL}). Flags
are central to many of the advanced features in DB, and it is crucial to
understand what you can and can't specify.  Once again, the main
API documentation should be the considered the definitive guide.


\subsection*{mkFlags}
One interesting non-API function found in RBerkeley is {\tt mkFlags}; this function provides
access to the internal constants defined by DB for use as flag
parameters to be passed to many of the internal functions. 

The C API allows for flags to be constructed via bitwise OR operations
on predefined DB constants.  In order to not map all constants into R, which
would be tedious, error-prone, and difficult to maintain, the
RBerkeley package passes a list of quoted or unquoted names from mkFlags
into C code which in turn performs this bitwise operation.  {\tt mkFlags} thus
allows for syntax very close in look and feel to the base C API, and at
the same time makes for a robust and safe mechanism to pass 
arbitrary combinations of flags correctly.  

<<mkFlags, keep.source=TRUE>>=
mkFlags(DB_CREATE)
mkFlags(DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL)
mkFlags(DB_CREATE,DB_EXCL,DB_EXCL) # bitwise OR no change
@

A programming note about this interface is that
unquoted symbols are converted to character vectors, and in turn concatenated into one
vector that is passed into the C level mkFlags function.  If illegal values are passed
they will simply be ignored in the calculation, and will produce a visible warning
regarding the specific invalid flag or flags that failed to be processed.
The return value will be unaffected by improper or duplicate settings.

\section{

\end{document}

